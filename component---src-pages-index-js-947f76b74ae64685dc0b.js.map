{"version":3,"sources":["webpack:///./src/pages/index.js"],"names":["Index","data","location","regionsDates","allRegionsZonesCsv","edges","forEach","item","index","node","Date","zones","allMarkdownRemark","nodes","frontmatter","id","html","zoneLabels","label","d","initialState","region","date","getDate","getMonth","getFullYear","useReducer","state","action","type","Error","dispatch","getZoneCode","getCurrentZoneCode","code","sameZones","getZoneLabel","Object","values","filter","value","self","indexOf","length","React","useEffect","localStorage","setItem","navigator","geolocation","storedRegion","getItem","avoidGeolocation","console","log","getCurrentPosition","position","latitude","coords","longitude","topojson","topodata","objects","regions","features","d3","properties","reg_name","Regions","dates","keys","className","getHeader","dangerouslySetInnerHTML","__html","getZoneText"],"mappings":"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","file":"component---src-pages-index-js-947f76b74ae64685dc0b.js","sourcesContent":["import React, {useReducer} from \"react\"\nimport {graphql} from \"gatsby\"\nimport {Regions} from \"../labels/regions\";\nimport RegionSelector from \"../components/region-selector\";\nimport DateSelector from \"../components/date-selector\";\nimport Layout from \"../components/layout\";\nimport * as topojson from \"topojson-client\";\nimport topodata from \"../data/limits_IT_regions.topo.json\";\nimport * as d3 from \"d3\";\nimport SEO from \"../components/seo\";\n\n\nexport default function Index ( { data, location } ) {\n  const regionsDates = {};\n  data.allRegionsZonesCsv.edges.forEach(function ( item, index ) {\n    regionsDates[item.node.Date] = item.node;\n  });\n\n  const zones = {};\n  data.allMarkdownRemark.nodes.forEach(function ( item, index ) {\n    zones[item.frontmatter.id] = item.html;\n  });\n\n  const zoneLabels = {};\n  data.allMarkdownRemark.nodes.forEach(function ( item, index ) {\n    zoneLabels[item.frontmatter.id] = item.frontmatter.label;\n  });\n\n  const d = new Date();\n  const today = d.getDate() + \"/\" + (d.getMonth() + 1) + \"/\" + d.getFullYear();\n\n  const initialState = { region: '0', date: today };\n\n  function reducer ( state, action ) {\n    switch (action.type) {\n      case 'region':\n        return { region: action.region, date: state.date };\n      case 'date':\n        return { region: state.region, date: action.date };\n      default:\n        throw new Error();\n    }\n  }\n\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  React.useEffect(() => {\n    if (state.region !== '0') {\n      localStorage.setItem('region', state.region);\n    }\n  }, [state]);\n\n  // Try to locate the user, only once.\n  React.useEffect(() => {\n    function success ( position ) {\n      const latitude = position.coords.latitude;\n      const longitude = position.coords.longitude;\n\n      // d3.geoContains works with geojson only.\n      const geodata = topojson.feature(topodata, topodata.objects.regions);\n\n      // Find the located region.\n      for (const region of geodata.features) {\n        if (d3.geoContains(region, [longitude, latitude])) {\n          dispatch({ type: 'region', 'region': region.properties.reg_name });\n          break;\n        }\n      }\n    }\n\n    function error () {\n      console.log('Unable to retrieve your location, will not bother you again');\n      // Do not bug people if they did not allow geolocation.\n      localStorage.setItem('avoid_geolocation', '1');\n    }\n\n    if (!navigator.geolocation) {\n      console.log('Geolocation is not supported by your browser');\n    }\n    else {\n      // No need to query if we already have a region.\n      if (state.region === '0') {\n        const storedRegion = localStorage.getItem('region') ?? '0';\n        const avoidGeolocation = localStorage.getItem('avoid_geolocation') ?? '0';\n        if (storedRegion === '0' && avoidGeolocation === '0') {\n          console.log('Locating...');\n          navigator.geolocation.getCurrentPosition(success, error);\n        }\n        else {\n          // Use the region from the localStorage\n          dispatch({ type: 'region', 'region': storedRegion });\n        }\n      }\n    }\n  }, []);\n\n  function getZoneCode ( date, region ) {\n    if (region !== '0' && date !== '0') {\n      return regionsDates[date][region];\n    }\n    else {\n      return '';\n    }\n  }\n\n  function getCurrentZoneCode () {\n    let code = getZoneCode(state.date, state.region);\n    // If all regions are in the same zone, the region is not mandatory.\n    if (state.date !== '0' && sameZones(state.date) && code === '') {\n      code = getZoneCode(state.date, 'Lombardia');\n    }\n    return code;\n  }\n\n  function getZoneLabel () {\n    const code = getCurrentZoneCode();\n    if (code) {\n      return zoneLabels[code];\n    }\n  }\n\n  function getZoneText () {\n    if (state.date !== '0') {\n      const code = getCurrentZoneCode();\n      if (code) {\n        return zones[code];\n      }\n      else if (sameZones(state.date)) {\n        return zones[getZoneCode(state.date, 'Lombardia')];\n      }\n      else {\n        return \"Per favore scegli una regione e una data.\";\n      }\n    }\n    else {\n      return \"Per favore scegli una regione e una data.\";\n    }\n  }\n\n  function getDate () {\n    return state.date !== '0' ? state.date : '';\n  }\n\n  function getRegion () {\n    return state.region !== '0' ? Regions[state.region] : '';\n  }\n\n  function getHeader () {\n    let code = getCurrentZoneCode();\n    if (code) {\n      if (sameZones(state.date)) {\n        return \"Tutte le regioni, \" + getDate() + \": \" + getZoneLabel();\n      }\n      else {\n        return getRegion() + \", \" + getDate() + \": \" + getZoneLabel();\n      }\n    }\n  }\n\n  // Returns whether all regions are in the same zone.\n  function sameZones ( date ) {\n    const dayZones = Object.values(regionsDates[date]);\n    const uniqueZones = dayZones.filter(( value, index, self ) => {\n      return self.indexOf(value) === index;\n    });\n    // Date is also a property.\n    return uniqueZones.length === 2;\n  }\n\n  return (\n    <Layout location={ location }>\n      <SEO></SEO>\n      <form>\n        <RegionSelector regions={ Regions } state={ state } dispatch={ dispatch }/>\n        <DateSelector dates={ Object.keys(regionsDates) } state={ state } dispatch={ dispatch }/>\n        <h2 className={ getCurrentZoneCode() }>\n          { getHeader() }\n        </h2>\n        <div dangerouslySetInnerHTML={ { __html: getZoneText() } }/>\n      </form>\n    </Layout>\n  )\n}\n\nexport const query = graphql`\n  {\n    allRegionsZonesCsv {\n      edges {\n        node {\n          Date\n          Abruzzo\n          Basilicata\n          Calabria\n          Campania\n          Emilia_Romagna\n          Friuli_Venezia_Giulia\n          Lazio\n          Liguria\n          Lombardia\n          Marche\n          Molise\n          Piemonte\n          Puglia\n          Sardegna\n          Sicilia\n          Toscana\n          Trentino_Alto_Adige\n          Umbria\n          Valle_d_Aosta\n          Veneto\n        }\n      }\n    }\n    allMarkdownRemark {\n      nodes {\n        html\n        frontmatter {\n          id\n          label\n          language\n        }\n      }\n    }\n  }\n`\n"],"sourceRoot":""}