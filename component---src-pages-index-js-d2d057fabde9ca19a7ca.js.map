{"version":3,"sources":["webpack:///./src/pages/index.js"],"names":["Index","data","location","regionsDates","allRegionsZonesCsv","edges","forEach","item","index","node","Date","zones","allMarkdownRemark","nodes","frontmatter","id","html","zoneLabels","label","d","initialState","region","date","getDate","getMonth","getFullYear","useReducer","state","action","type","Error","dispatch","getZoneCode","code","sameZones","getZoneLabel","Object","values","filter","value","self","indexOf","length","React","useEffect","localStorage","setItem","navigator","geolocation","storedRegion","getItem","avoidGeolocation","console","log","getCurrentPosition","position","latitude","coords","longitude","topojson","topodata","objects","regions","features","d3","properties","reg_name","Regions","dates","keys","className","getRegion","getHeader","dangerouslySetInnerHTML","__html","getZoneText"],"mappings":"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","file":"component---src-pages-index-js-d2d057fabde9ca19a7ca.js","sourcesContent":["import React, {useReducer} from \"react\"\nimport {graphql} from \"gatsby\"\nimport {Regions} from \"../labels/regions\";\nimport RegionSelector from \"../components/region-selector\";\nimport DateSelector from \"../components/date-selector\";\nimport Layout from \"../components/layout\";\nimport * as topojson from \"topojson-client\";\nimport topodata from \"../data/limits_IT_regions.topo.json\";\nimport * as d3 from \"d3\";\nimport SEO from \"../components/seo\";\n\n\nexport default function Index ( { data, location } ) {\n  const regionsDates = {};\n  data.allRegionsZonesCsv.edges.forEach(function ( item, index ) {\n    regionsDates[item.node.Date] = item.node;\n  });\n\n  const zones = {};\n  data.allMarkdownRemark.nodes.forEach(function ( item, index ) {\n    zones[item.frontmatter.id] = item.html;\n  });\n\n  const zoneLabels = {};\n  data.allMarkdownRemark.nodes.forEach(function ( item, index ) {\n    zoneLabels[item.frontmatter.id] = item.frontmatter.label;\n  });\n\n  const d = new Date();\n  const today = d.getDate() + \"/\" + (d.getMonth() + 1) + \"/\" + d.getFullYear();\n\n  const initialState = { region: '0', date: today };\n\n  function reducer ( state, action ) {\n    switch (action.type) {\n      case 'region':\n        return { region: action.region, date: state.date };\n      case 'date':\n        return { region: state.region, date: action.date };\n      default:\n        throw new Error();\n    }\n  }\n\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  React.useEffect(() => {\n    if (state.region !== '0') {\n      localStorage.setItem('region', state.region);\n    }\n  }, [state]);\n\n  // Try to locate the user, only once.\n  React.useEffect(() => {\n    function success ( position ) {\n      const latitude = position.coords.latitude;\n      const longitude = position.coords.longitude;\n\n      // d3.geoContains works with geojson only.\n      const geodata = topojson.feature(topodata, topodata.objects.regions);\n\n      // Find the located region.\n      for (const region of geodata.features) {\n        if (d3.geoContains(region, [longitude, latitude])) {\n          dispatch({ type: 'region', 'region': region.properties.reg_name });\n          break;\n        }\n      }\n    }\n\n    function error () {\n      console.log('Unable to retrieve your location, will not bother you again');\n      // Do not bug people if they did not allow geolocation.\n      localStorage.setItem('avoid_geolocation', '1');\n    }\n\n    if (!navigator.geolocation) {\n      console.log('Geolocation is not supported by your browser');\n    }\n    else {\n      // No need to query if we already have a region.\n      if (state.region === '0') {\n        const storedRegion = localStorage.getItem('region') ?? '0';\n        const avoidGeolocation = localStorage.getItem('avoid_geolocation') ?? '0';\n        if (storedRegion === '0' && avoidGeolocation === '0') {\n          console.log('Locating...');\n          navigator.geolocation.getCurrentPosition(success, error);\n        }\n        else {\n          // Use the region from the localStorage\n          dispatch({ type: 'region', 'region': storedRegion });\n        }\n      }\n    }\n  }, []);\n\n  function getZoneCode ( state ) {\n    let code = '';\n\n    if (state.date !== '0') {\n      if (state.region !== '0') {\n        code = regionsDates[state.date][state.region];\n      }\n\n      // If all regions are in the same zone, the region is not mandatory.\n      if (code === '' && sameZones(state.date)) {\n        code = regionsDates[state.date]['Lombardia'];\n      }\n    }\n\n    return code;\n  }\n\n  function getZoneLabel ( state ) {\n    const code = getZoneCode(state);\n    if (code) {\n      return zoneLabels[code];\n    }\n  }\n\n  function getZoneText ( state ) {\n    if (state.date !== '0') {\n      const code = getZoneCode(state);\n      if (code) {\n        return zones[code];\n      }\n      else if (sameZones(state.date)) {\n        return zones[getZoneCode(state.date, 'Lombardia')];\n      }\n      else {\n        return \"Per favore scegli una regione e una data.\";\n      }\n    }\n    else {\n      return \"Per favore scegli una regione e una data.\";\n    }\n  }\n\n  function getDate ( state ) {\n    return state.date !== '0' ? state.date : '';\n  }\n\n  function getRegion ( state ) {\n    return state.region !== '0' ? Regions[state.region] : '';\n  }\n\n  function getHeader ( state ) {\n    let code = getZoneCode(state);\n    if (code) {\n      if (sameZones(state.date)) {\n        return \"Tutte le regioni, \" + getDate(state) + \": \" + getZoneLabel(state);\n      }\n      else {\n        return getRegion(state) + \", \" + getDate(state) + \": \" + getZoneLabel(state);\n      }\n    }\n  }\n\n  // Returns whether all regions are in the same zone.\n  function sameZones ( date ) {\n    const dayZones = Object.values(regionsDates[date]);\n    const uniqueZones = dayZones.filter(( value, index, self ) => {\n      return self.indexOf(value) === index;\n    });\n    // Date is also a property.\n    return uniqueZones.length === 2;\n  }\n\n  return (\n    <Layout location={ location }>\n      <SEO></SEO>\n      <form>\n        <RegionSelector regions={ Regions } state={ state } dispatch={ dispatch }/>\n        <DateSelector dates={ Object.keys(regionsDates) } state={ state } dispatch={ dispatch }/>\n        <h2 className={ getZoneCode(state) }>\n          { getHeader(state) }\n        </h2>\n        <div dangerouslySetInnerHTML={ { __html: getZoneText(state) } }/>\n      </form>\n    </Layout>\n  )\n}\n\nexport const query = graphql`\n  {\n    allRegionsZonesCsv {\n      edges {\n        node {\n          Date\n          Abruzzo\n          Basilicata\n          Calabria\n          Campania\n          Emilia_Romagna\n          Friuli_Venezia_Giulia\n          Lazio\n          Liguria\n          Lombardia\n          Marche\n          Molise\n          Piemonte\n          Puglia\n          Sardegna\n          Sicilia\n          Toscana\n          Trentino_Alto_Adige\n          Umbria\n          Valle_d_Aosta\n          Veneto\n        }\n      }\n    }\n    allMarkdownRemark {\n      nodes {\n        html\n        frontmatter {\n          id\n          label\n          language\n        }\n      }\n    }\n  }\n`\n"],"sourceRoot":""}